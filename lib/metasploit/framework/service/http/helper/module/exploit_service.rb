require 'metasploit/framework/service/http/dto/exploit_details'
require 'metasploit/framework/service/http/dto/exploit_result'
require 'metasploit/framework/service/http/helper/module/payload_service'

module ExploitService

  class OutputSink

    attr_accessor :error
    attr_accessor :local_msg

    def initialize
      @local_msg = nil
      @error = false
    end

    def print(msg)
      @local_msg = msg
    end

    def print_line(msg)
      @local_msg = msg
    end

    def print_status(msg)
      @local_msg = msg
    end

    def print_good(msg)
      @local_msg = msg
    end

    def print_error(msg)
      @local_msg = msg
      @error = true
    end

    def prompting?
      return false
    end

    alias_method :print_bad, :print_error

    def print_warning(msg)
      @local_msg = msg
    end
  end

  def do_exploit(exploit_details)
    module_name = exploit_details.module_name
    module_object = load_module(module_name)
    verify_required_exploit_options(exploit_details.options, module_object.options)
    set_user_options(module_object, exploit_details.options)

    payload = PayloadService.get_payload(module_object, exploit_details.payload_hint)

    raise "Unable to load suitable payload" if payload.nil?
    result, message = run_exploit(module_object, payload)
    return ExploitResult.new({:module_name => module_name, :result => result, :message => message})
  end

  #######
  private
  #######

  def load_module(module_name)
    module_object = nil
    begin
      module_object = @framework.modules.create(module_name)
      raise "Invalid module reference" if module_object.nil?
    rescue => e
      raise "Unable to load module: \"#{module_name}\" error: #{e.message}"
    end

    return module_object
  end

  def set_user_options(module_object, user_options)
    datastore = module_object.datastore
    user_options.each { |key, value|

      # maybe enhance to fuzzy matching
      #module_option_key = get_module_option_key(key, module_object.options)
      datastore[key] =  value
    }

  end

  def get_module_option_key(user_key, module_options)
    module_options.each_key {|key|
      if user_key.casecmp(key).zero?
        return key
      end
    }

    raise "Unable to map passed option: #{user_key} to a module option"
  end

  def verify_required_exploit_options(passed_options, module_options)
    required_options = parse_required_options(module_options)
    return if required_options.empty?

    passed_keys = passed_options.keys.map {|key| key.downcase}

    missed_required_input = []
    required_options.each_key {|key|
      checked_value = key.downcase
      unless passed_keys.include?(checked_value)
        missed_required_input << checked_value
      end
    }

    unless missed_required_input.empty?
      raise "Missing input: #{missed_required_input.join(',')}"
    end
  end

  def parse_required_options(module_options)
    required_options = Hash.new
    module_options.each { |key, value|
        if value.required && value.default.nil?
          required_options[key] = value
        end
    }

    return required_options
  end

  def run_exploit(module_object, payload)
    begin
      output = OutputSink.new
      session = module_object.exploit_simple({
          'Payload' => payload,
          'LocalOutput' => output
      })

      if output.error
        return 'failed', output.local_msg
      end

      unless session.nil?
        session.close
        return 'success', output.local_msg
      end

      message = output.local_msg.nil? ? 'Exploit failed, missing session' : output.local_msg
      return 'failed', message
    rescue => e
      raise "Problem executing exploit: #{e.message}"
    end
  end

end